#! /bin/bash

BASE="git subundle"

die_usage()
{
    >&2 echo "$BASE: $@"
    >&2 echo "Usage: $SYNOPSYS"
    exit 1
}

die()
{
    CODE=$1
    shift
    >&2 echo "$BASE: $@"
    exit $CODE
}

try()
{
    [ -z "$DEBUG" ] || >&2 echo "#### Trying '$@'"
    "$@"

}

function do_reset()
{
    DIR="$1"

    [ -d "$DIR" ] || die 1 "Directory '$DIR' not found."

    for d in $(find "$DIR" -name ".git"); do
        GIT_DIR=${d%%/.git}
        echo "Reseting repository '$GIT_DIR'..."
        try git -C "$GIT_DIR" tag -d bundle bundlehead
    done
}

function pushd_hush()
{
    pushd "$@" > /dev/null
}

function popd_hush()
{
    popd "$@" > /dev/null
}

function do_create()
{
    REPO_DIR=$(readlink -e "$1")
    [ -d "$REPO_DIR" ] || die 1 "Directory '$REPO_DIR' not found."
    BUNDLE_BASE="${2%%.bundle}"
    [ -n "$BUNDLE_BASE" ] || BUNDLE_BASE=$(basename "$1")        # Not REPO_DIR because readlink may alter basename

    for DOT_GIT in $(find "$REPO_DIR" -name ".git"); do
        GIT_DIR=${DOT_GIT%%/.git}
        echo "Repository '$GIT_DIR'"
        RELATIVE_DIR=${GIT_DIR##$REPO_DIR}
        BUNDLE_FILE="${BUNDLE_BASE}${RELATIVE_DIR////_}.bundle"
        echo "... creating file '$BUNDLE_FILE'."
        BUNDLE_FILE=$(readlink -m "$BUNDLE_FILE")

        pushd_hush "$GIT_DIR"
        try git bundle create "${BUNDLE_FILE}" --all $(git show-ref|grep " refs/remotes/bundle"|cut -d" " -f2|sed -r 's/$/../') |& sed -r '/^warning: .*is excluded by/d'
        popd_hush
    done
}

function do_unbundle_helper()
{
    BUNDLE_FILE="$1"
    [ -e "$BUNDLE_FILE" ] || return 1
    GIT_DIR="$2"
    [ -n "$GIT_DIR" ] || die 1 "Missing git directory."
    echo "Bundle file '$BUNDLE_FILE'"
    echo "  -> directory '$GIT_DIR'"
    MODULE_GIT_DIR="$3"
    [ -z "$MODULE_GIT_DIR" ] || echo "  -> module directory '$MODULE_GIT_DIR'"

    branch="$(git bundle list-heads $BUNDLE_FILE | head -n 1| cut -d' ' -f2)" || branch="HEAD"
    branch=${branch##refs/heads/}
    echo "  -> branch '$branch'"

    if [ -n "$MODULE_GIT_DIR" ]; then
        MODULE=$(basename ${MODULE_GIT_DIR})

        if [ -e "$MODULE_GIT_DIR/.git" ]; then
            pushd_hush "$MODULE_GIT_DIR"
            if ! git remote | grep -q "^bundle$"; then
                try git remote add bundle "$BUNDLE_FILE"
            else
                # Remote bundle found. Make sure URL points to our BUNDLE_FILE
                if ! git remote -v | egrep -q "^bundle[[:space:]]+$BUNDLE_FILE"; then
                    die 1 "Remote 'bundle' exists but has the wrong URL. Aborting."
                fi
            fi
            try git -c fetch.prune=false fetch bundle
            try git bundle unbundle "$BUNDLE_FILE"           # Fetch does not fetch detached HEAD
            popd_hush
        else
            try git -C "$GIT_DIR" submodule init "$MODULE"
            try git -C "$GIT_DIR" config submodule."$MODULE".url $BUNDLE_FILE
            try git -C "$GIT_DIR" submodule update "$MODULE"

            pushd_hush "$MODULE_GIT_DIR"
            try git remote rename origin bundle
            try git bundle unbundle "$BUNDLE_FILE"           # Fetch does not fetch detached HEAD
            popd_hush
        fi

    else
        if [ -d "$GIT_DIR" ]; then
            pushd_hush "$GIT_DIR"

            if ! git remote | grep -q "^bundle$"; then
                # Remote bundle not found. Create one.
                try git remote add bundle "$BUNDLE_FILE"
            else
                # Remote bundle found. Make sure URL points to our BUNDLE_FILE
                if ! git remote -v | egrep -q "^bundle[[:space:]]+$BUNDLE_FILE"; then
                    die 1 "Remote 'bundle' exists but has the wrong URL."
                fi
            fi
            try git -c fetch.prune=false fetch --recurse-submodules=no bundle
            try git bundle unbundle "$BUNDLE_FILE"        # Fetch does not fetch detached HEAD

            popd_hush
        else
            try git clone -b $branch "$BUNDLE_FILE" -o bundle $GIT_DIR
        fi
    fi

    return 0
}

function do_unbundle()
{
    BUNDLE_BASE="${1%%.bundle}"
    [ -n "$BUNDLE_BASE" ] || die_usage 1 "Missing BUNDLE"
    DEST="$2"
    [ -n "$DEST" ] || DEST=$(basename "$BUNDLE_BASE")
    echo "Unbundling to '$DEST'..."

    GIT_DIR="$PWD/$DEST"

    do_unbundle_helper "$PWD/${BUNDLE_BASE}.bundle" "$GIT_DIR" && FOUND=true
    for BUNDLE_FILE in $PWD/${BUNDLE_BASE}_*.bundle; do
        MODULE_GIT_DIR="${BUNDLE_FILE//_//}"
        MODULE_GIT_DIR="${MODULE_GIT_DIR%%.bundle}"
        do_unbundle_helper "$BUNDLE_FILE" "$GIT_DIR" "$MODULE_GIT_DIR" && FOUND=true
    done

    [ -n "$FOUND" ] || die 1 "No bundle file found."
}

usage_help() {
# 34567890123456789012345678901234567890123456789012345678901234567890123456789| No char under and beyond | !
    cat <<- __END__
NAME
        $BASE - Create bundle including submodules.

SYNOPSYS
        $BASE [-h] [-b <name>] create [REPOSITORY] [BUNDLE_FILE]
        $BASE [-h] [-b <name>] unbundle [REPOSITORY] [BUNDLE_FILE]
        $BASE [-h] [-b <name>] reset [REPOSITORY]

DESCRIPTION
        Create bundle 'BUNDLE_FILE.bundle' that contains also submodules.

        -b <name>
                Use <name> as bundle remote name. If omitted, the default
                remote name is 'bundle'.

        -h
                Print this help.

        -d
                Debug output.

SEE ALSO
        git-bundle(1).
__END__
}

SYNOPSYS="$BASE [-hv] [-b <name>] create|unbundle|reset [BUNDLE_FILE] [REPOSITORY]"

getOptions() {
    BUNDLE_REMOTE=
    DEBUG=
    while getopts "b:hd" flag
    do
        case $flag in 
            b) BUNDLE_REMOTE=$OPTARG
                ;;
            d) DEBUG=true
                ;;
            h) usage_help
                exit 0
                ;;
            *) die_usage "Unknown option."
        esac
    done
}

BASEDIR=$(cd "$(dirname "${BASH_SOURCE[0]}" )" && pwd )

### Parse options
getOptions "$@"
shift $((OPTIND-1))
ACTION=$1
shift

case "$ACTION" in
    "reset")
        do_reset "$@"
        ;;
    "create")
        do_create "$@"
        ;;
    "unbundle")
        do_unbundle "$@"
        ;;
    *)
        die_usage "Missing or unknown action '$ACTION'"
        ;;
esac
